* Trabalho 11

** Consistência Sequencial

 - Modelo mais simples de consistência (extensão do modelo de um único processador)
 - Garantias: 
   1. Todas as operações em um único processador acontecem na ordem definida pelo programa
   2. Uma única ordem sequencial deve ser mantida entre todas as
      operações do programa

 - Vantagens
   - De uso extremamente fácil para programadores; coerente com a visão
	 "inocente" do funcionamento de um processador/memória.
   - Não-bloqueante

 - Aplicações: Sistemas pequenos/standalone, onde não é necessário
     realizar composição. 

 - Limitações: 
   + Não é composicional.
   + As garantias deste modelo possuem um preço bastante alto
	 + '1' impede o reordenamento de operações do programa, o que impede o
	   uso de vários tipos de otimização (hardware/software). Veja o exemplo
	   abaixo (em java, mas o princípio se aplica fora da JVM). É possível
	   que o programa imprima o resultado "(0,0)" devido à otimizações da
	   plataforma (write buffers, etc.), o que não aconteceria em um ambiente
	   sequencialmente consistente.

#+BEGIN_SRC
public class PossibleReordering {
	static int x = 0, y = 0;
	static int a = 0, b = 0;

	public static void main(String[] args) throws InterruptedException {
		Thread one = new Thread(new Runnable() {
			public void run() {
				a = 1;
				x = b;
			}
		});
		Thread other = new Thread(new Runnable() {
			public void run() {
				b = 1;
				y = a;
			}
		});
		one.start();
		other.start();
		one.join();
		other.join();
		System.out.println("( " + x + "," + y + ")");
	}
}
#+END_SRC

   + '2' requer que todas as escritas na memória sejam observáveis por
     todos os processadores ao mesmo tempo e na mesma ordem. É
     possível implementar protocolos de cache que atendam à esse
     requisito (utilizando mensagens de confirmação, por exemplo), mas
     o custo é alto.


** Consistência Quiescente

 - Garantias
   - Operações separadas por um período de quiescência devem aparentar
     tomar efeito em sua ordem temporal real.

	 + Em outras palavras: Uma vez que não haja mais operações em progresso
	 a estrutura/sistema alcança quiescência; quaisquer operações que
     ocorram futuramente não podem ser entrelaçadas com operações que
     ocorram antes deste ponto.

 - Exemplo: Uma pilha quiescentemente consistente
   - Assuma que a seguinte cadeia de operações ocorra na pilha:

     3 x push() [x,y,z]
     Quiescence (operações anteriores são processadas)
     3 x push() [a,b,c]
     Quiescence (operações anteriores são processadas)
     3 x pop()
     Quiescence (operações anteriores são processadas)
     3 x pop()
     Quiescence

	 Como a pilha é quiescentemente consistente, os três primeiros
     POPs retornarão a,b e c em uma ordem qualquer, e os próximos três
     retornarão x,y,z (novamente em uma ordem qualquer).


 - Vantagens
   - É composicional, ao contrário do modelo sequencial.
   - Maior performance/escalabilidade quando comparado aos outros modelos
   - Não-bloqueante, assim como o modelo sequencial.

 - Limitações
   - Não é imediatamente útil/aplicável quando comparado com modelos
     que provêem operações atômicas, como linearizabilidade. Isso
     exige maior esforço dos programadores.

 - Aplicações
   - Estruturas de dados onde modelos de consistência mais fortes não
     são necessários (ex: um pool de números únicos) ou resultariam em
     perdas de performance acima do aceitável (ver [3]).

** Linearizabilidade
 - Garantias
   - Operações podem ser corretamente "arrumadas", de acordo com a
     especificação do objeto, preservando a ordem das operações que
     não se sobrepõem no tempo.

	 + Toda computação linearizável é equivalente à uma computação
       sequencial legal.
	 + Caso uma operação retorne/termine, é garantido que os seus
       "efeitos" aconteceram no sistema.

 - Vantagens
   - Não-bloqueante.
   - Programadores podem visualizar operações linearizáveis como se
     fossem atômicas.
   - Local: se todos os componentes de um sistema são linearizáveis, o
     sistema é linearizável.
	 + Objetos podem ser implementados e verificados independentemente,
	   o que é bastante útil no desenvolvimento de um sistema.
   - Maior oportunidade de paralelismo quando comparado com o modelo
     sequencial.

 - Exemplo
   - Suponha que nós temos uma fila (FIFO) manipulada por diferentes
	 processos. Considere as duas execuções a seguir:

	 1. A:        |    enq(x)    |                   | deq(y) |                      
		B:           | enq(y) |         | deq(x) |                                    

	 2. A:        | enq(x) |          | deq(y) |                                      
		B:           | enq(y) |          | deq(y) |                                       

	 3. A primeira execução é consistente com uma fila linearizável;
        como as operações de enfileiramento aconteceram ao mesmo
        tempo, ambos os escalonamentos (enq(x) -> enq(y) e o oposto)
        são válidos.  A segunda não é consistente: o valor 'y' é
        desenfileirado duas vezes, o que não poderia acontecer em uma
        execução puramente sequencial.

 - Limitações
   - Provar que uma estrutura de dados é linearizável não é algo
     simples - um programador que decida criar do zero uma nova
	 estrutura poderá encontrar sérias dificuldades.

 - Aplicações

   - Descrição de sistemas grandes; localidade auxilia com o
   desenvolvimento e uso de componentes (ex: estruturas de dados
   concorrentes) de forma isolada.

** Serializabilidade
 - Garantias
   - Uma história (schedule) de transações é serializável se o
     resultado da sua execução é equivalente ao resultado das suas
     transações executadas sequencialmente sem sobreposição.

   - Similar à linearizabilidade, mas em um nível "macro":
     serializabilidade é uma propriedade global, ou seja, ela atua
     sobre um grupo de operações. Linearizabilidade é local, pois atua
     sobre uma única operação.

 - Exemplo
   - Considere as seguintes transações ocorrendo em paralelo:

	 [read/write = leitura/escrita na variável]

	 A.   | read(x) |              |     write(x)     |

	 B.         | read(x) |    | read(y) |                
	 
	 C.                                     | read(y) |    


     Em um modelo linearizável, é possível que eventos em transações
	 distintas aconteçam ao mesmo tempo:

	 LINEAR-HISTORY: A.read(x), B.read(x), B.read(y), A.write(x), C.read(y)

	 Em um modelo serializável, as operações são ordenadas de forma
	 que não haja entrelaçamento entre transações distintas:

	 SERIAL-HISTORY: A.read(x), A.write(x), B.read(x), B.read(y), C.r(y)

 - Vantagens
   - Todas as operações contidas em uma transação são executadas
     atomicamente em conjunto. 
   - Programadores podem pensar em transações como conjuntos
     de operações atômicas; não é necessário "limpar" o estado
	 do programa caso a transação falhe (ex: Memória Transacional
	 em Software)

 - Limitações
   - É necessário gerenciar as transações para garantir que o programa
     irá executar corretamente mesmo que uma transação falhe/trave. O
     custo desse sistema (em termos de performance) pode ser alto.

 - Aplicações
   - Sistemas de banco de dados, Memória Transacional.
   
** Happens-before
   Nota: O texto nesta seção tem como foco a especificação da
   linguagem Java. Outras linguagens possuem modelos de memória que
   utilizam happens-before, como C++11 (ver
   http://en.cppreference.com/w/cpp/atomic/memory_order).
   

 - Garantias
   - Dado duas operações A e B, se existir uma relação happens-before
     entre A e B, é possível afirmar que B pode ver os resultados de
     A.
	 + Todas as operações em um programa Java estão sujeitas à
       relações de happens-before conforme as regras descritas no
       modelo de memória (17.4.5).

 - Exemplo 
   - Temos aqui o mesmo exemplo utilizado antes para consistência
     sequencial, mas com uma pequena modificação: as variáveis a
	 e b são voláteis. Isso implica na existência de uma relação 
	 happens-before entre as escritas em 'a' e 'b' e as leituras
	 subsequentes durante a atribuição para 'x' e 'y'. Portanto,
	 não é mais possível que o resultado "(0,0)" seja impresso.
   
#+BEGIN_SRC
public class PossibleReorderingAvoided {
	static int x = 0, y = 0;
	volatile static int a = 0, b = 0;

	public static void main(String[] args) throws InterruptedException {
		Thread one = new Thread(new Runnable() {
			public void run() {
				a = 1;
				x = b;
			}
		});
		Thread other = new Thread(new Runnable() {
			public void run() {
				b = 1;
				y = a;
			}
		});
		one.start();
		other.start();
		one.join();
		other.join();
		System.out.println("( " + x + "," + y + ")");
	}
}
#+END_SRC

 - Vantagens
   - Dado que o programa é corretamente sincronizado, todas as
     execuções possíveis são sequencialmente consistentes.
   - Provê bastante liberdade para transformações no código,
	 como otimizações que reordenam operações ou remoção
	 de sincronização desnecessária.
	 - Isso não é possível em modelos mais fortes de consistência,
	   como consistência sequencial ou linearizável.
	 
 - Limitações
   - O programador é inteiramente responsável pelo uso correto das
     funcionalidades de sincronização disponíveis na linguagem.
	 - Erros de sincronização podem ser bastante sutis/complexos de se
       detectar (e ter consequências graves).
	 - Pesquisa visando trazer para a prática modelos de consistência
       mais fortes (ex: Memória Transacional) é algo crítico.

 - Aplicações
   Modelo de memória Java (e outras linguagens).

** Fontes

   - Shavit, Nir. "Data structures in the multicore age."
     Communications of the ACM 54.3 (2011): 76-84.
   - Attiya, Hagit, and Jennifer L. Welch. "Sequential consistency
     versus linearizability." ACM Transactions on Computer Systems
     (TOCS) 12.2 (1994): 91-122.
   - Moir, Mark, and Nir Shavit. "Concurrent data structures."
     Handbook of Data Structures and Applications (2007): 47-14.
   - Mankin, Jenny. "CSG280: Parallel Computing Memory Consistency
     Models: A Survey in Past and Present Research." (2007).
   - Göetz, Brian, et al. Java concurrency in
     practice. Addison-Wesley, 2006.
   - Gosling, James, ed. The Java language
     specification. Addison-Wesley Professional, 2000.
   - Herlihy, Maurice P., and Jeannette M. Wing. "Linearizability: A
     correctness condition for concurrent objects." ACM Transactions
     on Programming Languages and Systems (TOPLAS) 12.3 (1990):
     463-492.
   - Manson, Jeremy, William Pugh, and Sarita V. Adve. The Java memory model. Vol. 40. No. 1. ACM, 2005.
   - http://coldattic.info/shvedsky/pro/blogs/a-foo-walks-into-a-bar/posts/88
   - http://stackoverflow.com/questions/8200015/what-is-the-difference-between-serializability-and-linearizability
