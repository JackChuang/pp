Compare detalhadamente os modelos de consistência para sistemas paralelos discutidos ao longo da disciplina. Devem ser usados exemplos e discutidas questões como semelhanças e diferenças entre os modelos, as 
garantias por eles fornecidas, aplicações possíveis e o quão mais fácil é para um programador usar cada um (supondo que a linguagem ou infra-estrutura subjacentes garantam isso). Os modelos foram os seguinte:

1 - Consistência quiescente;

2 - Consistência sequencial;

3 - Linearizabilidade;

4 - Serializabilidade;

5 - Consistência Acontece-Antes.

Consistência Quiescente:
Uma execução é dita quiescentemente consistente se as chamadas de métodos podem ser organizadas corretamente, de maneira a garantir a ordem de execução de todas as chamadas, porém separadas por um 
período de quiescência, ou seja, um tempo em que nenhum outro método será chamado em qualquer segmento.

Exemplo:
Dois processos, P1 e P2, compartilham de uma mesma estrutura, enquanto o processo P1 escreve x, o segundo processo irá escrever y, próximo ao término da execução de ambos, o primeiro processo irá ler y. O intervalo das ações está dentro de um intervalo de quiescência "|".

P1: -----W(y)--|-----------|--R(y)----------
P2: --------------|--W(y)--|------------------

Esta condição de consistencia é mais forte do que a de consistencia sequencial, porém ainda não é forte o bastante para suprir o que se espera de um sistema multithread. A razão para um programador utilizar deste 
modelo é quando se deseja atingir um grau mais elevado de concorrência e um melhor tempo de resposta, e em contrapartida obtendo como retorno uma redução consideravelmente baixa na consistencia do sistema. 

Componentes de consistência quiescentes podem ser combinados de modo a formar componentes quiescentemente consistentes novamente. Ou seja, quiescentemente consistente é composicional.

/----------------------------------------------------------------------------------------------------------------------------------------------/
Consistência Sequencial:
Uma execução é dita sequencialmente consistente se todas as suas chamadas de método podem ser corretamente organizadas de maneira a manter a ordem de execução de cada chamada em cada segmento. 

Exemplo:
Dois processos, P1 e P2, compartilham da mesma estrutura de FIFO, enquanto o processo P1 enfileira x, o segundo processo irá enfileirar y, não necessariamente ao mesmo tempo, próximo ao término da execução de 
ambos, o segundo processo irá desenfileirar y. O intervalo das ações não está dentro de um intervalo de quiescência e podemos notar que é plenamente sequêncial.

P1: -----enq(x)---------------------deq(y)-----
P2: -------------enq(y)-----deq(x)-------------

No entanto, se nós combinamos duas execuções sequencialmente consistentes, o resultado não será sequencialmente consistente, ou seja, algo sequencialmente consistente não é composicional. 

Sequencialmente consistente e Quiescentemente Consistente não podem ser comparados, uma não implica a outra.  

Sequencialmente consistente é menos restritiva que linearizabilidade, já que os métodos podem tomar efeito depois de seu retorno.

Consistência seqüencial é uma garantia muito forte que é feita sobre a visibilidade e a ordem  de execução de um programa. Dentro de uma execução consistente em sequencial, há uma ordem total sobre todas 
as ações individuais. 

Se um programa não tem data races então todas as execuções deste programa parecerão ser sequencialmente consistentes.

/----------------------------------------------------------------------------------------------------------------------------------------------/
Serializabilidade:
Uma execução é dita serializável se os seus métodos e os métodos de cada segmento são agrupados em transações não-contínuas e ainda por cima sobrepostas, mas que apesar disso os seus métodos podem ser 
corretamente ordenados, de tal maneira a garantir que as operações realizadas ainda serão continuas.

A execução concorrente de um conjunto de transações que produzem algum estado final é serializável se alguma execução sequencial dessas transações produz este mesmo estado final. 

Em resumo, esta propriedade garante que o resultado da execução concorrente de um conjunto de instruções seja o mesmo resultado que poderia ser obtido pela sua execução de maneira sequencial.

Duas transações, A e B, uma que multiplica o valor dos dados por 2 e outra que incrementa em 1, respectivamente. Os dois valores de dados a serem alterados são inicialmente 0 e 10, se essas transações serão executadas uma após a outra, os novos valores para os dados serão 1 e 21, se a transação A for executada primeiro, ou 2 e 22, se for B a ser executada primeiro. 

A = 2x0, 2x10 = 0, 20
B = 0+1, 20+1 = 1, 21

B = 1+0, 1+10 = 1, 11
A = 2x1, 2x11 = 2, 22

Mas e se a ordem em que as duas transações são executadas fossem diferentes para CADA valor? Se a transação A fosse executada pela primeira vez no primeiro valor e a transação B é executado pela primeira vez no 
segundo valor, os novos valores são 1 e 22. Se essa ordem é invertida, os novos valores são 2 e 21. As transações são serializáveis ​​se 1, 21 e 2, 22, são os únicos resultados possíveis, no primeiro caso. Já no segundo 
caso as transações não são serializáveis já que 1, 22 e 2, 21 são possíveis resultados.

A = 2x0 ----- B = 10+1 
B = 0+1 ----- A = 2x11 

1, 22

B = 0+1 ----- A = 2x10
A = 2x1 ----- B = 20+1

2, 21 

/----------------------------------------------------------------------------------------------------------------------------------------------/
Linarizabilidade:
Linearizabilidade é uma condição de corretude para objetos concorrentes e que explora a semantica de tipos de dados abstratos. Esta condição é capaz de proporcionar a ilusão de que cada uma das operações aplicadas 
por processos concorrentes toma efeito instantaneamente em algum ponto entre a sua invocação e a sua resposta, com isso, podemos afirmar que o significado das operações de um objeto concorrente pode ser dada 
pelas suas pré e pós-condições. 

Ao contrário de outras condições de corretude mais alternativas, aqui já citadas, como sequencialmente consistente e serializabilidade, a linearizabilidade é uma propriedade local, ou seja, um sistema é dito linearizável se 
e somente se cada um de seus objetos forem linearizáveis.

Exemplo
Mais uma vez dois processos, P1 e P2 compartilham da mesma estrutura FIFO

P1: ----------enq(x)------deq(y)---------
P2: -------------enq(y)-----deq(x)-------

Linearizabilidade também permite um alto grau de concorrência, permitindo a programadores a possibilidade de utilizar conhecimentos provenientes de implementações sequenciais. 

Linearizabilidade é composicional. 

/----------------------------------------------------------------------------------------------------------------------------------------------/
Consistência Acontece-Antes.
Em uma relação acontece-antes, caso duas ações ocorram, e uma delas acontece-antes da outra, então a primeira ação a acontecer será a primeireira tanto a ser visível quanto a ser ordenada.

Se duas ações partilham de uma relação acontece-antes, elas não necessariamente deverão parecer ter acontecido na mesma ordem para qualquer outro trecho ou código que não partilhe uma relação acontece-antes com 
elas. 

Acontece-antes pode auxiliar na prevenção de data races, que acontecem quando diferentes processos/threads em execução dependem do resultado proveniente de um estado compartilhado que por sua vez 
depende do escalonamento de processos. 

Se um programa é corretamente sincronizado ele é sequenciamente consistente e livre de data races. Se um programa é corretamente sincronizado, então todas as execuções do programa parecerão ser sequencialmente 
consistentes. 

Esta que é um garantia fortíssima para programadores. Que agora não mais precisarão raciocinar sobre possíveis reordenações para determinar se seu código é livre de data races, ou raciocinar sobre reordenações para 
determinar se o seu código está corretamente sincronizado. Uma vez que seja determinado que um código está corretamente sincronizado, o programador não precisará mais se preocupar com o quanto reordenações 
afetarão seu código. 

Exemplo
Com consistencia acontece-antes é possível determinar quando uma thread P1 poderá ler um valor de P2.
P1 -> P2, P1 não pode ver o que P2 fez, como ler um valor por ele escrito.
P2 -> P2' -> P1, se P1 pode ver o que P2 fez, então P2' não existe. 
P2 -> P1, P1 pode ler um valor escrito por P2 ou uma ação por ele realizada. 
