Definições

Nota:
Os modelos de consistência descritos no livro AMP e lidos/discutidos em sala (Consistência Quiescente, Consistência Sequencial, Linearizabilidade, Serializabilidade) tomam uma abordagem orientada a objeto para explicar as diferentes características desses modelos enquanto que, surpreendentemente, a explicação dada pela JLS para o modelo de memória de Java NÃO assume uma abordagem OO para explicar a Consistência Acontece-Antes. As explicações de cada modelo abaixo levam em consideração as respectivas abordagens tentando fazer as devidas associações onde possível.

Modelos de memória
Modelos de memória descrevem os possíveis comportamentos de um determinado programa, isto é, dado um programa, o mesmo pode descrever (prever) as possíveis sequências de execução (ações) legais para esse determinado programa. De acordo com a JLS[1] e [2], o modelo de memória de uma linguagem deve ser capaz de responder que valores podem ser lidos em cada ponto de um programa

Consistência Acontece-Antes

A consistência “Acontece-Antes” está relacionada à definição da relação de ordem parcial “acontece-antes” descrita na JLS. A mesma é definida informalmente como:
Para toda leitura (volátil)¹ “r” do conjunto de ações de um programa, esse conjunto é dito “acontece-antes consistente” se não é o caso que (1) a ação de escrita “W(r)” vista por “r”  acontece-antes de “r” ou (2) não existe uma outra ação de escrita w tal que W(r) acontece-antes de w e w acontece-antes de r.
Esse modelo não leva em consideração ações não definidas pela relação “acontece-antes”, por exemplo, ignora leituras e escritas em variáveis não-volatile, além disso, mesmo que certas ações possuam uma relação de acontece-antes com outras, ações que não possuam uma relação “acontece-antes” entre si não oferecem as garantias dadas por esse modelo.
Basicamente, a garantia dada por este modelo é que cada leitura “vê” uma escrita que é permitida ver através da relação “acontece-antes” (se a mesma está definida para a leitura), isso significa que para ações que possuam essa relação existe uma noção de linerizabilidade.
Para os desenvolvedores, a utilização de uma linguagem que utiliza esse modelo significa que os mesmos devem explicitamente se preocupar com a sincronização adequada de toda leitura/escrita, em Java isso significa uso adequado de variáveis volatile, blocos synchronized, etc.

¹ A definição formal não deixa explícito que as leituras devem ser voláteis, mas por definição a relação de “acontece-antes” não está definida para leituras/escritas não voláteis.


Consistência Quiescente
Esse modelo define que chamadas separadas por um período de quiescência (período no qual nenhuma thread está executando um método no objeto)¹ sempre observarão valores consistentes com os efeitos colaterais de todas as chamadas completadas antes do período de quiescência. É importante observar que nesse modelo não há garantias de preservação da ordem do programa, entretanto, os resultados das chamadas que se sobrepõem antes do período de quiescência ainda assim deve obedecer a especificação sequencial do objeto.
Uma importante propriedade desse modelo é que ele é composicional, isto é, é possível construir estruturas quiescentes a partir de outras estruturas quiescentes.
Pode-se utilizar estruturas quiescentes quando não há a necessidade de  uma ordenação explicíta (e estrita) entre as chamadas dos métodos de um objeto, [3] mostra um exemplo de uma pilha quiescente.
Do ponto de vista dos desenvolvedores, a  utilização de uma linguagem com tal modelo nem sempre é trivial pois a própria ordem do programa não precisa ser respeitada o que não é intuitivo.

¹Nas definições lidas não há menção de quanto tempo é necessário para o período de quiescência.


Consistência Sequencial
No modelo de consistência sequencial, chamadas a métodos devem parecer tomar efeito de acordo com a ordem do programa de cada thread e são atômicas e imediatamente visíveis à todas outras threas, entretanto, ações entre threads podem ser reordenadas arbitrariamente desde que a especificação sequencial do objeto seja mantida. 
Esse modelo de consistência não é composicional.
Com relação à facilidade de uso tal modelo pode ser mais fácil de utilizar se não considerarmos as ações ordenadas pela relação “acontece-antes” já que o modelo se aplica a todas as operações, entretanto, para ações relacionadas por “acontece-antes” as garantias fornecidas são mais fortes (linearizabilidade).
Faz sentido o uso desse modelo quando não ocorre data racing no programa. Porém, mesmo em casos onde é garantido a consistência sequencial e não há data racing, podem ocorrer erros vindos de um grupo de operações que deveriam ser enxergadas como atômicas mas não são.


Linearizabilidade
Esse modelo garante que as chamadas de métodos tomam efeito em qualquer ponto entre a invocação e o retorno do método. Um das implicações disso é que este modelo garante a preservação da ordem do programa, além disso, para chamadas não sobrepostas, chamadas temporalmente subsequentes em outras threads observam os efeitos de todas as chamadas completadas anteriormente. Para chamadas sobrepostas tal regra não é válida e qualquer reoordenação que mantém a ordem do programa e atende à especificação sequencial da estrutura de dados é válida.
Igualmente à consistência “acontece-antes”, apesar de garantir consistência entre operações, esse modelo não garante consistência para blocos de operações.
Assim como no modelo de consistência quiescente, linearizabilidade é composicional e, por isso, sistemas linearizáveis podem ser compostos por outros sistemas linearizáveis. 
Dito isto, esse modelo é muito simples de ser utilizado caso hajam somente sistemas linearizáveis.

Serializabilidade
Esse modelo de consistência aparece como uma extensão da noção de “linearizabilidade” garantindo atomicidade para um conjunto de operações (chamadas de métodos) e não somente uma única operação. Esse modelo provê as melhores garantias de consistência entre todos os modelos e também é um dos mais fáceis de ser utilizado.


Referências:
[1] http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4
[2] http://shipilev.net/blog/2014/jmm-pragmatics/
[3] http://cacm.acm.org/magazines/2011/3/105308-data-structures-in-the-multicore-age/fulltex
[4] http://coldattic.info/shvedsky/pro/blogs/a-foo-walks-into-a-bar/posts/88
[5]The Art of Multiprocessor Programming