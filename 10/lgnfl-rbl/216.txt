In TinyTM, the LockObject class's onCommit() handler first checks whether the object is locked by another transaction and then whether its stamp is less than or equal to the transaction's read stamp.

Q: Give an example showing why it is necessary to check whether the object is locked.

A: Two concurrent threads could commit a transaction with data that was already changed. Suppose one thread is right before checking if the object is locked, while another thread is almost finishing a commit that changes that data (it did not update the stamp just yet). If the first thread did not check if the object was locked and owned by another thread, then it would have continued based on that bogus data.

Q: Is it possible that the object could be locked by the committing transaction?

A: Yes, it could happen if the same object is in both readSet and writeSet simultaneously.

Q: Give an example showing why it is necessary to check whether the object is locked before checking the version number.

A: If this order is changed, one thread could check versions first and see it's ok, but then it is rescheduled and another thread goes faster, checking the version is also OK, obtaining the lock and finally commiting and updating the timestamp. When the slower thread finally get the chance to run again, it will be able to obtain the lock as well, but note that the stamp was already modified. So the order here is important.