211. Olhar implementações nas branches prioritycm, greedycm e karmacm.
Para a implementação do PriorityContentionManager (branch prioritycm) as classes alteradas foram TThread e Transaction.
Para a implementação do GreedyContentionManager, além das modificações nas classes acima, mais uma modificação foi realizada na classe Transaction
Para o KarmaContentionManager, mais uma vez a classe transaction foi modificada além das classes AtomicObject, LockObject e FreeObject.

215. 
public T openRead() {
    Transaction me = Transaction.getLocal();
    switch (me.getStatus()) {
      case COMMITTED:
        return openSequential();
      case ABORTED:
        throw new AbortedException();
      case ACTIVE:
        Locator locator = start.get();
        if (locator.owner == me) {
          return locator.newVersion;
        }
        Locator newLocator = new Locator();
        while (!Thread.currentThread().isInterrupted()) {
          Locator oldLocator = start.get();
          Transaction writer = oldLocator.owner;
          switch (writer.getStatus()) {
            case COMMITTED:
              newLocator.oldVersion = oldLocator.newVersion;
              break;
            case ABORTED:
              newLocator.oldVersion = oldLocator.oldVersion;
              break;
            case ACTIVE: 
				// If newVersion == oldVersion it means the object was open for reading and we shouldn't worry about read conflicts
				if(oldLocator.newVersion != oldLocator.oldVersion) {
					ContentionManager.getLocal().resolve(me, writer);
					continue;
				} else {
					// We use oldVersion == newVersion to indicate that the owner is just "reading"
					newLocator.newVersion = oldLocator.newVersion;
					break;
				}
          }
          if (start.compareAndSet(oldLocator, newLocator)) {
            return newLocator.newVersion;
          }
        }
        me.abort(); // time's up
        throw new AbortedException();
      default:
        throw new PanicException("Unexpected transaction state");
    }
  }


216
	1. Considerando que duas threads A e B possuam conflitos read-write em ambas direções (A escreve em uma variável lida por B e B escreve numa variável lida por A), caso não houvesse a verificação de travamento para os elementos do ReadSet seria possível que as duas transações comittassem sem conflito. Se A passa da verificação do ReadSet antes de B committar e B também passa da verificação antes de A commitar, já que isso seria possível sem a verificação de travamento, ambas poderiam finalizar o commit mesmo existindo um conflito claro entre as duas.
	2. Sim, se o objeto for lido e escrito ele fará parte do WriteSet da transação e teria sido travado anteriormente
	3. Considere duas threads A e B que possuam conflitos read-write no qual A escreve em uma variável lida por B, se a verificação do timestamp fosse realizada antes da verificação de travamento nos objetos to ReadSet, seria possível (1) que a verificação do timestamp ocorresse com sucesso em B e a thread B fosse suspensa, (2) que a thread A comittasse a transação adiquirindo e consequentemente liberando a trava, (3) que a thread B fosse resumida, verificasse o travamento, também com sucesso já que A já liberou a trava) e committasse com sucesso quando na verdade deveria falhar.

123. A solução utiliza como base para resolver o problema do inferno de Dante uma fila síncrona starvation free. Assumiu-se que uma pessoa (thread) nunca poderia simultaneamente estar sendo alimentada e alimentando e por isso foi escolhida uma fila síncrona. Sempre que uma thread quer alimentar, a mesma enfileira uma "comida", e sempre que uma thread estiver disposta a receber comida, a mesma tenta remover um alimento da fila. Como a fila é síncrona, ambas threads bloqueam até que elas possoam "cooperar" para que uma possa alimentar a outra.
A ausência de deadlock é garantida assegurando a alternância entre comer e alimentar das threads participantes, isto é, incialmente é escolhido um grupo de threads que irá alimentar e um grupo que será alimentado. Após alimentar, uma thread esperará ser alimentada até tentar alimentar novamente e vice-versa. Como a fila utilizada é síncrona, após um par de threads cooperar, uma nova thread passará a esperar por comida enquanto que a outra passará a oferecer comida, isso garante que sempre existirão threads alimentando e threads esperando ser alimentadas. Além disso, a fila utilizada é starvation free e, portanto, deadlock free.
O algoritmo é justo pois utiliza uma fila justa para ordernar as requisições de alimentar/esperar por comida, então uma thread que requisitou comida primeiro será alimentada assim que uma thread que alimenta estiver disponível e vice-versa.
A fila utilizada é starvation free pois utiliza uma trava única e justa¹ para controlar o acesso à mesma. Não há espera circular, somente uma thread pode estar executando os métodos enq/deq de cada vez e, por ser justa, a trava garante que a política FIFO para as threads que tentarem adquirí-la. Objetos Condition são utilizados para realizar o processo de cooperação entre as threads que estão alimentando e as threads que estão sendo alimentadas.
Como o algoritmo é deadlock free e justo, podemos afirmar que o mesmo é starvation free.

¹ ReentrantLock passando o valor 'true' para o construtor da mesma