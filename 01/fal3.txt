1. Descreva a arquitetura do seu computador pessoal em termos dos seguintes itens:

	. Frequência de clock:
	  > Processador Intel(R) Core(TM) i5-2450M, frequência de clock:
		2.50 GHz [1]
	  
	  
	. Número de núcleos (físicos e virtuais) do processador:
	  > Total de 6 núcleos [1], sendo:
		Núcleos Físicos:  2
	      ||   Virtuais:  4
	
	. Número de níveis de cache e onde as memórias cache estão localizadas:
	  > Total de 3 níveis, sendo que o nível 1 (L1) é dividido em dois tipos:
		+ L1 Data (para armazenamento de dados)
		  - Localizada de forma integrada ao core, bem próxima ao controlador de memória
		+ L1 Inst (para armazenamento de instruções)
		  - Localizada de forma integrada ao core
		+ Level 2 
		  - Localizada de forma integrada ao core
		+ Level 3
		  - Localizada externamente aos cores, compartilhada
	  
	. Como o processador mantém coerência das memórias cache?
	  > O processador analisado, Intel(R) Core(TM) i5-2450M, segue a arquitetura Sandy Bridge [1]. Nesta arquitetura, é utilizado o protocolo MESIF para garantir a coerência entre as memórias cache. O procotolo MESIF um protocolo snooping, segundo [3], é baseado no clássico protocolo MESI (Modified-Exclusive-Shared-Invalided), adicionando um estado de encaminhamento para prevenir que múltiplas caches aguardem por uma linha compartilhada, quando esta linha é requisitada por outra cache do core. 
	  
	  Por ser um protocolo snooping, ele segue o funcionamento básico em que caches individuais monitoram linhas de endereço para acesso à locais de memória que elas têm armazenado. Quando uma operação de escrita é observada para um local que uma cache tem cópia, o controlador de cache invalida sua própria cópia da localização de memória interceptada.
	
	. As instruções atômicas não-triviais (por exemplo, um LOAD ou um STOR são instruções "triviais" por fazerem apenas uma coisa) que estão disponíveis e o que elas fazem:
	  > Para a arquitetura x86:
	    - BTC: Seleciona o bit (especificado com o primeiro operando, chamado bit base) em uma string de bit, numa posição bit designada pelo operando do bit de deslocamento (segundo operando), armazena o valor do bit em uma flag CF, e complementa o bit selecionado na string de bit.
	    - BTR: Seleciona o bit (especificado com o primeiro operando, chamado bit base) em uma string de bit, numa posição bit designada pelo operando do bit de deslocamento (segundo operando), armazena o valor do bit em uma flag CF, e limpa o bit selecionado na string de bit para 0.
	    - BTS: Seleciona o bit (especificado com o primeiro operando, chamado bit base) em uma string de bit, numa posição bit designada pelo operando do bit de deslocamento (segundo operando), armazena o valor do bit em uma flag CF, e define o bit selecionado na string de bit para 1.
	    - CMPXCHG: Compara o valor no registrador AL, AX ou EAX (dependendo do tamanho do operando) com o primeiro operando (operando de destino). Se dois valores são iguais, o segundo operando (operando fonte) é carregado em no operando de destino. Senão, o operando de destino é carregado no registrador AL, AX ou EAX.
	    - CMPXCHG8B: Compara o valor 64-bit no EDX:EAX com o operando (operando de destino). Se os valores forem iguais, o valor 64-bit em ECX:EBX é armazenado no operando destino. Senão, o valor no operando destino é carregado no EDX:EAX.
		- XADD: Troca o primeiro operando (operando destino) com o segundo operando (operando fonte), então, carrega a soma dos dois valores no operando destino. O operando destino pode ser um registrador ou uma localização de memória; o operando fonte é um registrador.
		- XCHG: Troca o conteúdo dos operandos destino (primeiro) e fonte (segundo). Os operandos podem ser registradores de propósito geral ou um registrador e um endereço de memória. S um operando de memória é referenciado, o protocolo de bloqueio do processador é automaticamente implementado para a duração da operação de troca, independentemente da presença ou ausência do prefixo LOCK (que garante instruções complexas atômicas) ou do valor do IOPL.
	  
	. A velocidade da memória que está rodando na sua máquina. Ela é rápida o suficiente para o processador? Sim? Não? Por que?
	  > Teoricamente sim. De acordo com a especificação do processador [4], a largura de banda máxima de memória é de 21,3GB/s. Na máquina estão instalados dois pentes de memória DDR3-1333, operando em Dual Channel. Desta forma:
	    - Largura de banda máxima de memória suportada pelo processador: 21,3 GB/s * 1024 -> 21811,2 MB/s
	    - Largura de banda utilizada pelas memórias em Dual Channel: 1333 Mhz * 128 bits / 8 = 21328 MB/s
		- Velocidade do processador: 2500MHz * 64 bits / 8 = 20000 MB/s
	  
	  Apesar disso, em uma análise mais detalhada, é preciso levar em conta outros aspectos para determinar se existe algum tipo de gargalo referente à comunicação entre processador e memória. Um destes aspectos é a velocidade do barramento, caso a largura do barramento (em termos físicos) não seja capaz de suportar altas velocidades do processador ou da memória, os cálculos para obter a informação de suficiência são irrelevantes.
	
2. Você já precisou construir programas paralelos, seja por motivos de estudo, seja por motivos profissionais? Escolha o mais complexo desses programas e descreva-o. Explique porque ele precisa realizar várias atividades ao mesmo tempo e em que consistiam essas atividades. Esse programa era "embaraçosamente" paralelo ou exigia sincronização entre as tarefas? Que problemas você enfrentou ao construí-lo (ou ajudar a construí-lo)?
  > Já precisei construir um programa didático que simula o comportamento de um escalonador de processos, utilizando a estratégia de filas circulares, constituída por três filas, permitindo as operações de: criação, visualização, bloqueio e finalização dos processos. A técnica de paralelismo utilizada consistia em resolver dois problemas: 1) manter a consistência entre os processos, de forma que a ação de criar processos não interferisse na execução dos processos, e 2) executar os processos de duas ou mais filas de forma paralela.
  O primeiro problema é um exemplo em que era necessária a sicronização entre as tarefas. O segundo problema, a execução dos processos em filas diferentes de forma paralela, demonstra ser um problema "embaraçosamente" paralelo, já que a execução dos jobs nestas filas ocorria de forma independente entre as filas.
  As dificuldades envolvidas na construção do programa envolveram a dificuldade em visualizar o comportamento do sistema em um primeiro momento. Além disso a escolha das técnicas de concorrência e paralelismo também trouxe impactos no nível de complexidade para o desenvolvimento do sistema.

REFERÊNCIAS

[1] Intel Core i5-2450M Mobile processor - FF8062700995606. Citado em 07/07/2014.
	Disponível em: http://www.cpu-world.com/CPUs/Core_i5/Intel-Core%20i5-2450M%20Mobile%20processor.html#specs
[2] 2nd Generation Intel® CoreT Processor Family: Intel® CoreT i7, i5 and i3. Citado em 07/07/2014.
	Disponível em: http://research.engineering.wustl.edu/~songtian/pdf/intel-sandy.pdf
[3] Modelling Communications in Cache Coherent Systems. Citado em 07/07/2014.
	Disponível em: http://htor.inf.ethz.ch/publications/img/ramos-hoefler-cc-modeling.pdf
[4] Intel® CoreT i5-2450M Processor (3M Cache, up to 3.10 GHz). Citado em 07/07/2014.
	Disponível em: http://ark.intel.com/products/53452/intel-core-i5-2450m-processor-3m-cache-up-to-3_10-ghz