Exercise 120. Consider the simple lock-free queue for a single enqueuer and a single
dequeuer, described earlier in Chapter 3. The queue is presented in Fig. 10.20.

class TwoThreadLockFreeQueue<T> {
	int head = 0, tail = 0;
 	T[] items;

public TwoThreadLockFreeQueue(int capacity) {
 	head = 0; tail = 0;
 	items = (T[]) new Object[capacity];
}

public void enq(T x) {
	while (tail - head == items.length) {};
>>> aqui!
	items[tail % items.length] = x;
tail++;
>>> aqui!
 	
}

public Object deq() {
	while (tail - head == 0) {};
	>>> aqui!
 	Object x = items[head % items.length];
	head++;
>>> aqui!
 	return x;
 	}
}

This queue is blocking, that is, removing an item from an empty queue or inserting an item to a full one causes the threads to block (spin). The surprising thing about this queue is that it requires only loads and stores and not a more powerful read–modify–write synchronization operation. Does it however require the use of a memory barrier? If not, explain, and if so, where in the code is such a barrier needed and why?

Sim, precisa dessa barreira de memória para garantir que não haja alteração da lista no momento em que a thread localiza a posição onde deve inserir/remover o elemento, ou seja, as instruções marcadas no código dentro do “aqui” (barreira de memória) não podem ser executadas fora de ordem. 

Exercise 121. Design a bounded lock-based queue implementation using an array instead of a linked list. 
1. Allow parallelism by using two separate locks for head and tail.

2. Try to transform your algorithm to be lock-free.Where do you run into difficulty?


Exercise 122. Consider the unbounded lock-based queue’s deq() method in Fig. 10.8. Is it necessary to hold the lock when checking that the queue is not empty? Explain.

Sim. Se fila for bloqueada apenas após verificar que a mesma não está vazia, neste intervalo de tempo a fila poderia ficar vazia podendo ocorrer NullPointerException caso só tenha 1 elemento da lista e 2 threads tentando remover;

Exercise 123. In Dante’s Inferno, he describes a visit to Hell. In a very recently discovered chapter, he encounters five people sitting at a table with a pot of stew in the middle. Although each one holds a spoon that reaches the pot, each spoon’s handle ismuch longer than each person’s arm, so no one can feed him- or herself. They are famished and desperate. Dante then suggests “why do not you feed one another?”
The rest of the chapter is lost.

1. Write an algorithm to allow these unfortunates to feed one another. Two or
more people may not feed the same person at the same time. Your algorithm
must be, well, starvation-free.

Nosso algoritmo é starvation-free, pois o "unfortunate" alimenta o "unfortunate" imediatamente a direita e quem foi alimentado só será alimentado novamente depois que o "unfortunate" que o alimentou também for alimentado.

2. Discuss the advantages and disadvantages of your algorithm. Is it centralized,
decentralized, high or low in contention, deterministic or randomized?

Possui contenção pois a thread só prossegue a execução depois que todas as demais threads foram alimentadas. O nosso algoritmo é determinístico pois a thread só pode alimentar o vizinho da direita.


Exercise 124. Consider the linearization points of the enq() and deq() methods of the lock-free queue:

1. Can we choose the point at which the returned value is read from a node as the linearization point of a successful deq()?
Não podemos escolher a linha 38 como sendo o ponto de linealização pois não é o ponto em que a operação é concluída. Ou seja, não é o ponto que a operação tem efeito.


2. Can we choose the linearization point of the enq() method to be the point at which the tail field is updated, possibly by other threads (consider if it is within the enq()’s execution interval)? Argue your case.

Sim, pois o método só será bem sucedido nos pontos 17 e 21 (Thread amiga) onde o campo de tail será alterado para o novo nó. E assim as operações serão visiveis para as outras threads.

