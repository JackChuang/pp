* Trabalho 9
** 120
Sim. As variáveis 'head' and 'tail' precisam ser 
declaradas como "volatile" para o algoritmo funcionar
corretamente. Do contrário, é possível que uma das
threads observe valores incorretos para estas variáveis
durante uma operação "enq"/"deq".

*** 121
**** 1 

package pp;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class BoundedLockQueue<T> {
	volatile int head = 0, tail = 0;
	T[] items; //this should be an AtomicReferenceArray, but I don't think it's allowed
	Lock ll = new ReentrantLock(), rr = new ReentrantLock();

	public BoundedLockQueue(int capacity) {
		head = 0;
		tail = 0;
		items = (T[]) new Object[capacity];
	}

	public void enq(T x) {
		while (tail - head == items.length) {};
		ll.lock();
		try {
			items[tail % items.length] = x;
			tail++;
		} finally {
			ll.unlock();
		}
	}

	public Object deq() {
		while (tail - head == 0) {};
		rr.lock();
		try {
			Object x = items[head % items.length];
			head++;
			return x;
		} finally {
			rr.unlock();
		}
	}
}

**** 2 

 - Sincronizar acessos à elementos do array. Como as operações atuam sobre
   um mesmo array, elas se baseiam em índices para saber aonde começa/termina
   a fila. Esses índices são manipulados em ambas as operações, de forma que 
   é bastante complicado sincronizar o acesso sem o uso de locks.

*** 122
Sim. Do contrário, caso hajam mais threads realizando deq()'s do que elementos na fila, é
possível que uma thread tente desenfileirar um elemento que não existe. Exemplo:

  Fila:     [a] ;; contém apenas 1 elemento, 'a'
  Threads:  A & B
  
  - A invoca deq(), mas o escalonador para a Thread imediatamente depois de 'if (head.next == null)'
  - B invoca deq(), e prossegue normalmente até o fim do método. A fila agora está vazia.
  - A volta a ser executado. Como A já testou se a fila estava vazia, o método será executado como
    se houvessem elementos na fila, o que é um erro.


*** 123
**** 1

 - Uma das almas (aleatoriamente) recebe um token. 
 - While (alguém estiver com fome):
   - A alma com o token:
	 - Dá uma colher de comida para a alma à sua esquerda
	 - Passa o token para a alma da direita
   - Almas sem token não fazem nada

implementação:
-----------------------------
package pp;

import java.util.Random;

public class Hell {

	volatile static int index;
	static Soul[] souls;
	static int nSouls;
	
	
	public Hell(int nSouls) {
		Hell.nSouls = nSouls;
		souls = new Soul[nSouls];
		index = new Random().nextInt(nSouls);
		
		for (int i = 0; i < nSouls; i++) {
			souls[i] = new Soul(i);
		}
	}
	
	static class Soul extends Thread {
		
		static volatile boolean shouldStop = false;
		
		volatile int nProd = 0; //vezes que alimentou alguem
		volatile int nCons = 0; //vezes que comeu
		final int id;
		
		public Soul(int id) {
			this.id = id;
		}
		
		public void run() {
			while(!shouldStop) {
				if (index == id) {
					this.nProd++;
					souls[(id + nSouls - 1) % nSouls].nCons++;
					index = (index + 1) % nSouls;
				} else {
					try {
						System.out.printf("Soul #%d: fed:%d, ate:%d\n",id,nProd,nCons);
						Thread.sleep(1);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		}
	}
	
	public static void main(String[] args) throws InterruptedException {
		Hell hell = new Hell(5);
		for (Soul s : Hell.souls) {
			s.start();
		}
		Thread.sleep(5000);
		Soul.shouldStop = true;
		
		System.out.println("#####################");
		for (Soul s : Hell.souls) {
			s.join();
			System.out.printf("Soul #%d: fed:%d, ate:%d\n",s.id,s.nProd,s.nCons);
		}
	}
}
-----------------------------------
 - Este algoritmo/implementação é starvation-free. Prova:
   1. Há um número finito de almas/objetos 'Soul' durante qualquer execução do programa.
   2. Alimentar uma alma requer um número finito de passos (as três linhas após "if (index == id)")
   3. As almas são alimentadas em um esquema justo (round-robin):
     - Cada 'Soul', ao ser escalonado, pode tomar duas ações: caso a variavel 'index' seja igual ao 'id' de Soul,
       ele irá alimentar a alma da esquerda (souls[id - 1]), e incrementar 'index' para registrar que é a vez
       da próxima alma de alimentar alguém. Do contrário, a alma invoca Thread.sleep(1).
   - A partir de 1, 2 e 3, podemos concluir que:
   4. Uma alma que não esteja sendo alimentada precisa aguardar um tempo finito do para ser alimentada novamente.
      
     

**** 2
 O algoritmo é centralizado (o token decide quem alimenta quem), com alta contenção
 (outra pessoa poderia estar sendo alimentada) e determinístico (o algoritmo segue
 uma ordem round-robin).

*** 124
**** 1

Não, porque é possível (e esperado) que a chamada para compareAndSet na linha
39 funcione, o que irá alterar o ponteiro para o primeiro elemento da fila.

**** 2
Sim - o próprio livro texto diz isso na página 232. 

Razão: Caso tail.compareAndSet(last, node) falhe, podemos afirmar que uma outra
thread tentou avançar tail em um momento anterior e foi bem sucedida.

