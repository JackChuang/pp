Exercise 120. Consider the simple lock-free queue for a single enqueuer and a single dequeuer, described earlier in Chapter 3. The queue is presented in Fig. 10.20. This queue is blocking, that is, removing an item from an empty queue or inserting an item to a full one causes the threads to block (spin). The surprising thing about this queue is that it requires only loads and stores and not a more powerful read–modify–write synchronization operation. Does it however require the use of a memory barrier? If not, explain, and if so, where in the code is such a barrier needed and why?

Sim, a barreira de memória trata-se de um tipo de barreira de instrução que faz com que a CPU ou o compilador cumpram uma ordem de restrição de memória em operações emitidas antes e depois da instrução de barreira.  O acesso desenfreado por multiplas threads à determinadas regiões tanto de memória quanto aos valores alocados para variavéis pode fazer com que resultados diferentes dos que deveriam ser vistos naquele momento, apareçam, e assim interfiram na corretude do algoritmo.  Na thread enfileiradora a necessidade de uma barreira de memória fica para as linhas 10 e 11 do algoritmo, que caso executem em ordem distinta levarão ao problema já mencionado de inconsistência, já para a thread desinfileiradora está nas linhas 15 e 16. 

Exercise 121. Design a bounded lock-based queue implementation using an array instead of a linked list.

1.Allow parallelism by using two separate locks for head an tail.

package lista9;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

/**
 *
 * @author Carlos
 */
 
public class BoundedArrayQueue<T> {
	ReentrantLock enqLock, deqLock;
	Condition notEmptyCondition, notFullCondition;
	AtomicInteger size;
	int capacity;
	private int contador;
  private int[] vetor;
  private int enqIndice = 0, deqIndice = 0;
	
	public BoundedArrayQueue(int_capacity){
      capacity = _capacity;
      size = newAtomicInteger(0);
      enqLock = newReentrantLock();
      notFullCondition = enqLock.newCondition();
      deqLock = newReentrantLock();
      notEmptyCondition = deqLock.newCondition();
      vetor = new int[capacity];
      }
		
public void enq(T x) {
booleanmustWakeDequeuers =false;
enqLock.lock();
	
	try{
		while(size.get() == capacity)
			notFullCondition.await();
			vetor[enqIndece] = (Integer) x;
		
			if(vetor.length<size){
				enqIndece = ++enqIndece;
			}else{
				enqIndece = 0;
			}
			
		if(size.getAndIncrement() == 0)
			mustWakeDequeuers =true;
	}finally{
		enqLock.unlock();
	}
	
	if(mustWakeDequeuers) {
		deqLock.lock();
		try{
		notEmptyCondition.signalAll();
		}finally{
		deqLock.unlock();
		}
	}
}

publicT deq() {
	T result;
	booleanmustWakeEnqueuers = true;
	deqLock.lock();
	
	try{
		while(size.get() == 0)
		notEmptyCondition.await();
		int vetor = vetor[deqIndex];
		vetor[deqIndex] = 0;
	
			if(vetor.length<size){
				deqIndece = ++deqIndece;
			}else{
				deqIndece = 0;
			}
	result = vetor;
	
		if(size.getAndIncrement() == capacity) {
			mustWakeEnqueuers =true;
		}
	}finally{
		deqLock.unlock();
	}
	
	if(mustWakeEnqueuers) {
		enqLock.lock();
	
	try{
		notFullCondition.signalAll();
	}finally{
		enqLock.unlock();
		}
		}
		return result;
}

2.Try to transform your algorithm to be lock-free. Where do you run into difficulty?

Link para uma tese http://www.cse.yorku.ca/~niloo/Research_files/thesis.pdf que detalha muito bem o assunto. 

Exercise 122. Consider the unbounded lock-based queue’s deq() method in Fig. 10.8. Is it necessary to hold the lock when checking that the queue is not empty? Explain.

Sim, graças ao travamento que ocorre na décima terceira linha podemos evitar o acesso a objetos que ainda não tenham sido instanciados e/ou inseridos na fila, garantindo que o método deq() seja thread-safe, ou seja, evitamos um NullPointerException que seria resultado de um número maior de desenfileiramento do que enfileiramento. 

Exercise 123. In Dante’s Inferno, he describes a visit to Hell. In a very recently discovered chapter, he encounters five people sitting at a table with a pot of stew in the middle. Although each one holds a spoon that reaches the pot, each spoon’s handle is much longer than each person’s arm, so no one can feed him- or herself. They are famished and desperate.
Dante then suggests “why do not you feed one another?”
The rest of the chapter is lost.

1.Write an algorithm to allow these unfortunates to feed one another. Two or more people may not feed the same person at the same time. Your algorithm must be, well, starvation-free.

2.Discuss the advantages and disadvantages of your algorithm. Is it centralized, decentralized, high or low in contention, deterministic or randomized?


Exercise 124. Consider the linearization points of the enq() and deq() methods of the lock-free queue:

1. Can we choose the point at which the returned value is read from a node as the linearization point of a successful deq()?
Não, pois até então a chamada não tomou efeito, o ponto de linearização desta função está no compareAndSet da linha 38.  

2. Can we choose the linearization point of the enq() method to be the point at which the tail field is updated, possibly by other threads (consider if it is within the enq()’s execution interval)? Argue your case.
Sim, a partir daí a chamada toma efeito e outras threads poderão trabalhar em cima desse valor, inicialmente atualizando o valor da cauda, (que é uma das caracteristicas dos pools, que diferem dos sets por permitirem modificações em suas sentinelas) e podendo realizar uma nova inserção ou ainda complementar o trabalho de uma thread que já esteja inserindo.
