101. Explain why the fine-grained locking algorithm is not subject to deadlock.

Because it's always acquiring locks in key order (first pred, then curr). If you can determine a specific ordering for threads to acquire locks, then you avoid deadlocks.

--

102. Explain why the fine-grained list's add() method is linearizable.

Quote: "" It is enough to identify a linearization point, a single atomic step where the method call "takes effect." This step can be a read, a write, or a more complex atomic operation. Looking at any execution history of list-based set, it must be the case that if the abstraction map is applied to the representation at the linearization points, the resulting sequence of states and method calls defines a valid sequential set execution. ""

A successful call (an element is not found in the set) is linearized when the node with the next higher key is locked (either Line 7 or 13). At that point, we have a valid set representation and also hold locks for both predecessor and successor of the element we're about to add. Any other function call who tries to modify these will wait until the method add finishes. So when the element is finally added, we retain a valid state for that set and then both locks are released.

--

103. Explain why the optimistic and lazy locking algorithms are not subject to deadlock.

Because they're always acquiring locks in key order (first pred, then curr). If you can determine a specific ordering for threads to acquire locks, then you avoid deadlocks.

--

105. Provide the code for the contains() method missing from the fine-grained algorithm. Explain why your implementation is correct.

public boolean contains(T item) {
	int key = item.hashCode();
	Entry pred = this.head;
	Entry curr = pred.next;
	pred.lock();
	try {
		curr.lock();
		try {
			while (curr.key < key) {
				pred.unlock();
				pred = curr;
				curr = curr.next;
				curr.lock();
			}
			return curr.key == key;
		} finally { curr.unlock(); }
	} finally { pred.unlock(); }
}

It traverses the list of nodes acquiring both predecessor lock and current locks. This way we protect from concurrent changes that comes from behind like a removal of the desired node by acquiring the predecessor lock and also from changes in the desired node itself by acquiring the current lock. Once we find the first node that has the same key or its key is greater than we desire, we stop and check whether the element is indeed the one that it was looking for.

--

106. Is the optimistic list implementation still correct if we switch the order in which add() locks the pred and curr entries?

Para que não seja possível que aconteça deadlocks, a ordem de aquisição dos locks (pred e cur) deve ser a mesma para todos o métodos. Se apenas o método add() estiver com a ordem trocada, o algoritmo estará susceptível a deadlocks, logo a implementação não pode ser considerada correta.

--

108. Show that in the optimistic algorithm, the add() method needs to lock only pred.

It would still be safe from interference. If threads concurrently attempt to add(), then would both need to acquire the same pred lock in order to finish it. If a concurrent remove() happens, the remove() would still need to acquire both pred and curr locks. If another thread attempts to remove the element being added by add(), they would both acquire the same lock, so it would be safe. If another thread attempts to remove an element lower than prev, then that thread will need to acquire pred's predecessor lock and pred's lock, so this would also be safe. And if the element removed was the immediate successor of the element being added, the removing thread would need to acquire pred's lock if the element was not succesfully added yet, and this would be safe as well.

--

110. Would the lazy algorithm still work if we marked a node as removed simply by setting its next field to null? Why or why not? What about the lock-free algorithm?

O algoritmo lazy não funcionaria com pois o método contains() ficaria inconsistente. Ao mudar o curr.next para null em remove(), outra thread poderia estar executando o método contains(), e o loop das linhas 4 e 5 poderia parar exatamente no nó que foi removido e não percorrer o restante da lista.

O algoritmo lock-free também não funcionaria pelo mesmo motivo, o método contains() ficaria inconsistente.

--

112. Your new employee claims that the lazy list's validation method (Fig. 9.16) can be simplified  by dropping the check that pred.next is equal to curr. After all, the code always sets pred to the old value of curr, and before pred.next can be changed, the new value of curr must be marked, causing the validation to fail. Explain the error in this reasoning.

Suppose a remove(D) and add(C) are both running concurrently and elements in the set are: [A, B, D]. Before acquiring any locks, the remove method gets scheduled and now add method runs. At that remove method point, pred=B and curr=D. When the add runs, also pred=B and curr=D, the validation would be OK and then C would be added between B and D. So now the set is [A, B, C, D] and both locks are released. Back to remove method, it acquire both locks (B and D) and attempt to validate. Since both nodes are not marked at all, and we don't check for changes in pred.next (as proposed in the problem statement), we won't see that C is now in the set. It turns out that the remove method will in fact remove D, but make B points to the successor of D, so C would just become unreachable from head, so the remove method would no longer be linearizable.

--

115. In the lock-free algorithm, if an add() method call fails because pred does not point to curr, but pred is not marked, do we need to traverse the list again fromhead in order to attempt to complete the call?

Não, é necessário iterar sobre a lista desde o começo pois pode ter havido insersões antes do nó `pred`. Neste caso seria necessário reposicionar o nó que está sendo inserido para respeitar a invariante relativa ao ordenamento das chaves.

--

118. Explain why the following cannot happen in the LockFreeList algorithm. A node with itemx is logically but not yet physically removed by some thread, then the same itemx is added into the list by another thread, and finally a contains() call by a third thread traverses the list, finding the logically removed node, and returning false, even though the linearization order of the remove() and add() implies that x is in the set.

A segunda thread, durante a execução do find() para achar a posição que `x` vai ser inserido, iria remover fisicamente `x` (que já foi logicamente removido). Logo, o cenário descrito não é possível, pois a terceira thread encontraria o elemento `x`.
