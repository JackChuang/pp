#################################### FRGV ######################################

Trabalho 08.

Exercise 101. Explain why the fine-grained locking algorithm is not subject to
deadlock.

      Porque fine-grained garante que os métodos adiquirem os locks na sequência
      correta.

Exercise 102. Explain why the fine-grained list’s add() method is linearizable.

      Como descrito no livro página 204, o ponto de linearização é dado se a
      chamada foi bem sucedida. Essa chamada indica que o elemento já existe na
      lista, caso não exista a chamada não é bem sucedida.

Porque o método garante que o próximo node já está travado. O mesmo se aplica para
o removed(), garantindo que o node predecessor já está travado.

Exercise 103. Explain why the optimistic and lazy locking algorithms are not sub-
ject to deadlock.

      Todos os bloqueios respeito uma sequência de chamadas, ou seja, mesmo que
      todos as threads queiram o mesmo elemento da lista o mesmo só será adquirido
      quando for a sua vez.

Exercise 105. Provide the code for the contains() method missing from the fine-
grained algorithm. Explain why your implementation is correct.

public boolean contains(T item) {
    Node pred = null, curr = null;
    int key = item.hashCode();
    head.lock();
    try {
      pred = head;
      curr = pred.next;
      curr.lock();
      try {
        while (curr.key < key) {
          pred.unlock();
          pred = curr;
          curr = curr.next;
          curr.lock();
        }
        return (curr.key == key);
      } finally {
        curr.unlock();
      }
    } finally {
      pred.unlock();
    }
}

Exercise 106. Is the optimistic list implementation still correct if we switch the
order in which add() locks the pred and curr entries?

      Sim, porque é feito uma validação a mais para que ocorra a operação, o
      optimistic procuro pelo item sem fazer nenhum lock, depois de encontrar o item,
      assim sim trava e válida se o pred contiua disponível e se o mesmo aponta
      para o curr, somente ao final da checagem efetua a operação. Isso nos garante
      que mesmo com a troca da ordem do travamento haverá mais nova checagem.


Exercise 108. Show that in the optimistic algorithm, the add() method needs to
lock only pred.

      No método add() há dependencia direta do pred, pois a thread que deseja adici-
      onar novo item trava os elementos pred e curr, porém faz uma nova checagem
      se pred ainda aponta para o curr, porém se curr poderia ser removido, mas 
      não o pred, caso o pred não esteja disponível o novo item não pode ser
      adicionado.

Exercise 110. Would the lazy algorithm still work if we marked a node as removed
simply by setting its next field to null? Why or why not? What about the lock-free
algorithm?

      Não, Porque isso implicaria na finalização da lista, já que não haveria
      referencia pra ele ou para o seu sucessor.

Exercise 112. Your new employee claims that the lazy list’s validation method
(Fig. 9.16) can be simplified by dropping the check that pred.next is equal to
curr. After all, the code always sets pred to the old value of curr, and before
pred.next can be changed, the new value of curr must be marked, causing the
validation to fail. Explain the error in this reasoning.

      Não é viável, dado a concorrencia a chacagem é fundamental para a atualização
      dos elementos da lista em todas as operações. Incluindo a possibilidade de
      ocorrer multiplas inserções.

Exercise 115. In the lock-free algorithm, if an add() method call fails because pred
does not point to curr, but pred is not marked, do we need to traverse the list
again from head in order to attempt to complete the call?

      Se o pred não aponta mais para o curr, isso inplica dizer que, outra thread
      adicionou outro item a lista, o que não nos mostra onde o item deve ser
      inserido, porém sabemos que a inserção se dará apartir do pred, mas o mesmo
      não estando marcado implica na falha da adição do item. Sendo necessário uma
      nova entrada na lista.

Exercise 118. Explain why this cannot happen in the LockFreeList algorithm.
A node with item x is logically but not yet physically removed by some thread,
then the same item x is added into the list by another thread, and finally a
contains() call by a third thread traverses the list, finding the logically removed
node, and returning false, even though the linearization order of the remove()
and add() implies that x is in the set.

      O item removido logicamente ainda está presente, porém ao ser novamente
      inserido inplicaria primeiramente na remoção física, com a atualização da
      lista, feita na busca com o find, o find não encontraria o item já marcado
      como removido.
