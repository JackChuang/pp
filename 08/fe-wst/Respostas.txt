Exercise 101. Explain why the fine-grained locking algorithm is not subject to
deadlock.

Exercicio 101 - O algoritmo é livre de deadlock pois só é possível conseguir o lock do nó posterior após conseguir o lock do nó anterior, ou seja, não há espera circular. Para conseguir os locks, os métodos seguem sempre essa sequência. Não há preempção. 

===============================================


Exercise 102. Explain why the fine-grained list’s add() method is linearizable.

Exercicio 102 - O algoritmo fine-grained é linear pois garante que o resultado da execução do método add() seja mantido (como se a execução fosse sequencial).

Exemplo: 

Thread A : add(1);
Thread B : add(2);

ou 

Thread B : add(2);
Thread A : add(1);

Idependente da ordem que as Threads forem executas. Estas sequências vão apresentar o mesmo resultado.

A partir da linha 7 e 13 nenhuma outra Thread pode alterar o nó. Desta forma, é garantida que o nó sempre esteja com o valor mais recente.

===============================================


Exercise 103. Explain why the optimistic and lazy locking algorithms are not subject to deadlock


Exercise 103 - Em ambas implementações, a lista sempre é lida na mesma sequência (pred -> curr), não há dependência cíclica (espera circular), ou seja, se uma thread A tem o lock do pred e uma outra thread B tenta adiquirí-lo, a thread B vai conseguir o lock assim que a thread A liberar. Ou seja, nunca vai ocorrer que ao mesmo tempo a Thread B obtenha o lock de um recurso que a Thread A almeja e a thread A ter o lock de um recurso que a Thread B deseja. 

===============================================


Exercise 105. Provide the code for the contains() method missing from the fine-grained algorithm. Explain why your implementation is correct.

public boolean contains(T item) {
	Node pred = null, 
	Node curr = null;
	int key = item.hashCode();
	head.lock();
	try {
		pred = head;
		curr = pred.next;
		curr.lock();
		try {
			while (curr.key < key) {
			pred.unlock();
			pred = curr;
			curr = curr.next;
			curr.lock();
			}
			if (curr.key == key) {
				return true;
			}
			return false;
		} finally {
			curr.unlock();
		}
		} finally {
		pred.unlock();
	}
}

O método contains() apresentado é correto pois garante os seguintes itens:
(i) é livre de deadlock: devido a sequencia de aquisição de lock seguida pelos métodos; 
(ii) mantém o abtract map do algorítmo: os itens podem ser sempre alcançados a partir do head.


===============================================


Exercise 106. Is the optimistic list implementation still correct if we switch the
order in which add() locks the pred and curr entries?

Exercise 106: Não! Além de poder causar Deadlock, pode gerar 2 listas inconsistentes, por exemplo: uma threadA esta inserindo o item na lista, e como ela vai fazer o lock do curr primeiro, pode ser que uma threadB remova o pred antes da threadA fazer o seu lock. Assim, o next do item removido irá apontar para o curr em vez de apontar para o novo item.

Exemplo:

1. lista inicial: [Head -> A -> B -> D]
2. threadA vai inserir o item C entre B e D. 
3. threadA faz o lock de D
4. threadB faz o lock de B para removê-lo
5. threadA fica no aguardo do lock de B enquanto threadB o remove
6. threadB faz A apontar para D
7. threadA faz B apontar para C, e C apontar para D
8. a lista final seria: [Head -> A -> D <- C <- B]


Para que a mudança na ordem de obtenção de lock continue correto, todos os outros métodos que utilizam lock devem seguir esta nova ordem de travamento.



===============================================

Exercise 108. Show that in the optimistic algorithm, the add() method needs to
lock only pred.

Exercise 108 - Não é necessário bloquear o nó atual pois não será realizada nenhuma alteração nele, apenas no nó anterior. 

===============================================



Exercise 110. Would the lazy algorithm still work if we marked a node as removed
simply by setting its next field to null? Why or why not? What about the lock-free
algorithm?	

Exercise 110 - Em nenhum dos algoritmo é possivel atribuir null ao próximo elemento. Pois a atribuição de null ao próximo elemento da lista quebraria a invariancia dela (o abstract map das implementações). Ou seja, não seria possível alcançar todos os nós da lista. 


===============================================

Exercise 112. Your new employee claims that the lazy list’s validation method
(Fig. 9.16) can be simplified by dropping the check that pred.next is equal to
curr. After all, the code always sets pred to the old value of curr, and before
pred.next can be changed, the new value of curr must be marked, causing the
validation to fail. Explain the error in this reasoning.

private boolean validate (Node pred, Node curr) {
return !pred.marked && !curr.marked && pred.next == curr;
}

Excerise 112 - Para o método add(), o problema se localiza no momento antes de fazer o lock e depois que ter achado a posição do pred e curr. Pois alguma outra thread pode ter adicionado/removendo algum elemento entre o pred e o curr, e o add() precisa conferir este caso, para não inserir na posição errada na lista.





===============================================

Exercise 115. In the lock-free algorithm, if an add() method call fails because pred
does not point to curr, but pred is not marked, do we need to traverse the list
again from head in order to attempt to complete the call?

Excerise 115 - Não. É necessário varrer a lista novamente desde o Head quando o pred é removido. No caso da questão, é adicionado algum elemento entre o Pred e o Curr ou o Curr é removido, sendo assim, é necessário percorrer a partir do Pred (a chamada do find() poderia ser feita passando o Pred em vez do Head). Visto que alterações nos elementos anteriores ao Pred (não incluindo ele) não interferem no add() do elemento em questão.


===============================================


Exercise 118. Explain why this cannot happen in the LockFreeList algorithm.
A node with item x is logically but not yet physically removed by some thread,
then the same item x is added into the list by another thread, and finally a
contains() call by a third thread traverses the list, finding the logically removed
node, and returning false, even though the linearization order of the remove()
and add() implies that x is in the set.

Este caso não pode acontecer pois o método find() executado pelo add() faz a remoção física do elemento e em seguida o método add() faz a adição normalmente de um novo elemento x. Assim, o contains() deveria retornar true pois o elemento x está de volta na lista.


