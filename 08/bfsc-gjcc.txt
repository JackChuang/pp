Exercise 101
Porque todos os métodos adquirem os locks na mesma ordem, do ínicio (head) ao fim (tail) da lista, seguindo as referências next dos nós. Caso contrário, seria possível que threads adquirissem locks que outras estivessem desejando e vice-versa, causando deadlock. (e.g. Figure 9.10 no AMP).

Exercise 102
A forma usual de se mostrar que uma implementação é linearizável é identificar um ponto de linearização, onde o método surte efeito. Em implementações baseadas em locks, sessões críticas podem exercer esse papel. (sec. 3.5.1, AMP).  
O ponto de linearização do método add() depende se a chamada obtém sucesso (i.e, se o item a ser adicionado já existe). Se a chamada obter sucesso (o item não existe), o método é linearizável quando o nó com o maior valor seguinte é travado (linha 7 ou 13, Figure 9.6, AMP). Já uma chamada sem sucesso (o item está presente) é linearizável quando o nó que contém o item é travado.

Exercise 103
Se vários processos estão tentando travar o mesmo elemento da lista, este é livre de deadlock se o algoritmo de bloqueio utilizado for livre de deadlock. Ambas a implementações, assim como visto na a fine-grained (exercise 101), é livre de deadlock porque todas as threads travam/destravam os elementos na mesma ordem na lista.

Exercise 105
    public boolean contains(T item) {
        Node last = null, pred = null, curr = null;
        int key = item.hashCode();
        head.lock();
        try {
            pred = head;
            curr = pred.next;
            curr.lock();
            try {
                while (curr.key < key) {
                    pred.unlock();
                    pred = curr;
                    curr = curr.next;
                    curr.lock();
                }
                return (curr.key == key);
            } finally {
                curr.unlock();
         }
        } finally {
            pred.unlock();
        }
    }

O contains funciona pelo mesmo princípio  de "lock coupling" dos outros métodos: adquire-se a trava pro nó curr enquanto estiver com o trava do lock de pred. Além disso, para garantir progresso, todas as threads também travam/destravam os elementos na mesma ordem na lista. Suponha que curr.key == key retorna false. Se curr.key > key procede. Da invariante de ordenamento da lista, pred.next == curr e pred.key < key, podemos concluir que o item não pode estar na lista. Suponha por outro lado que curr.key == key retorna true. Daí segue pela propriedade de unicidade das chaves que curr.item = item, assim, o item está no conjunto.

Exercise 106
Sim. Porque o algoritmo ainda continua a fazer sua validação independente da ordem dos travas. A validação verifica se o rastro de referências levando até pred ou a referência de pred a curr não mudaram enquanto elas foram lidas pela última vez pela thread ao adquirir as travas, caso tenha mudado, a validação falha sem efeitos colaterais. 

Exercise 108
No método add() apenas é necessário "travar" o pred pois:
1. O método contains() não sofre influência do add(), dado que adicionar um elemento na lista concorrentemente ou não, não faria o método contains() entrar num estado inválido, pois caso o item pesquisado exista na lista o mesmo continuará existindo antes, durante ou depois de um add().
2. Quanto ao método remove, as duas únicas possibilidades de inconsistência ocorrem quando tenta-se adicionar um elemento imediatamente anterior a outro que se deseja remover, ou remover um elemento imediatamente anterior ao que deseja-se adicionar. Os possíveis estados inválidos seriam ter o item adicionado mas o outro não removido ou vice-versa. No entanto, isso não pode ocorrer porque o remove só prossegue caso obtenha o lock de pred e curr e o add só prossegue se adquirir o lock de pred. Assim, na primeira possibilidade o pred de add é igual ao pred de remove e quem obter o lock primeiro impede o outro de entrar em sua região crítica. E na segunda possibilidade o pred de add é igual ao curr de remove e da mesma forma somente o primeiro que adquirir o lock prossegue impedindo o outro de entrar em sua região crítica.

Exercise 110
O algoritmo lazy nao funciona porque ao marcar o next do nó que se deseja remover como null na linha 17, a linha 18 setaria o next de pred como null, removendo todo o restante da lista a partir do nó que se deseja remover. Mesmo se trocássemos a linha 18 do remove com a linha 17 (remoção física e posterior remoção lógica) poderia-se ter uma sequencia de threads chamando contains e remove com estados inválidos. Por exemplo, uma thread executando contains terminar de executar a linha 5 (quebrando o loop) e é suspensa com o valor de curr=item, em seguida outra thread executa remove até a linha 17 (antiga 18) e faz a remoção física, então a thread de contais retornar e executa a linha 6, verificando que curr.next não é null (não está marcado) e portanto retornar true, apontando que o item buscado está na lista. No entanto a thread de remove retorna e ao executar a linha 18 (antiga linha) só agora marca o nó, fazendo sua remoção lógica.
O algoritmo Lock-free não funciona pelo mesmo motivo do lazy, descrito anteriormente.

Exercise 112
Não foi levado em conta o método add, que pode modificar pred.next sem marcar curr. A implementação modificada não seria mais linearizável. Especificamente, suponha que nós temos uma instância vazia do cojunto, s, e uma thread T1 executa s.add(1) até a linha 9. Nesse ponto, pred e curr apontam para os dois nós sentinelas da lista. Em particular, curr.key == key não passa (linha 6). Agora, outra thread T2 executa s.add(1) até completar, retornando true para indicar que obteve sucesso. Finalmente, T1 continua sua execução. A chamada a validate retorna true já que nenhum dos nós sentinelas foram marcados. Além disso, curr.key == key continua sem passar (linha 14). Daí, T1 reinsere 1 na lista e também retorna true, mesmo 1 já estando presente na lista.

Exercise 115
Não é necessário percorrer toda a lista, basta iniciar a partir do pred uma vez que a única forma dessa situação acontecer é se um método add estiver concorrendo com outro(s) método(s) add. Estando uma thread suspensa na linha 10 e outra thread consegue adicionar um novo nó (linha 11 entra no if) faria com que o pred da thread suspensa não apontasse para o curr (mas sim para o nó acrescendando pela segunda thread), mesmo pred não estando marcado para remoção. Assim o nó que a primeira thread deseja acrescentar teria ficar entre pred e cur, podendo ser antes ou depois do novo nó acrescentado pela segunda thread e por isso não precisaria começar a partir da cabeça da lista, mas sim a partor de pred.

Exercise 118
O evento descrito não pode acontecer por conta da verificação feita na linha 16 do método find, utilizado pelo método add quando vai adicionar o novo elemento x. Esse trecho verifica que o elemento curr está marcado (o x marcardo para remoção) e por isso faz o pred apontar para o succ, retornando para o método os valores de pred e curr de forma a ignorar o elemento x marcado para remoção. Assim o contais quando percorrer a lista não irá se deparar com o elemento x marcado para remoção.
