======= Exercício 11: =======

Mutual exclusion:
------------------------------------

Pelo código, vemos que:

write_a(turn = A) -> read_a(busy == false) -> write_a(busy = true) -> read_a(turn == A) -> CS_a
write_b(turn = B) -> read_b(busy == false) -> write_b(busy = true) -> read_b(turn == B) -> CS_b

Suponha que a thread A seja a primeira a entrar na CS (critical section). Isso só acontece se `read_a(turn == A) -> CS_a`. Se uma thread B executar a escrita write_b(turn = B) logo após a CS_a [CS_a -> write_b(turn = B)], ela não entrará na CS_b, pois read_b(busy == true) durante toda a execução de CS_a. Se a thread B já tiver executado `write_b(turn = B) -> read_b(busy == false)` antes de A entrar na CS_a, B não irá entrar na CS_b já que para isso read_b(turn == B), o que não é verdade, pois para entrar em CS_a, read_a(turn == A). Mesmo que na iteração seguinte write_b(turn = B), essa alteração não surtirá efeito, já que read_b(busy = true).

Deadlock-freedom:
------------------------------------

Considere a seguinte execução:

write_a(turn = A) -> read_a(busy == false) -> write_a(busy = true) -> write_b(turn == B) -> read_a(turn == B)

A thread A realizará outra iteração após read_a(turn == B).

A partir de então tanto A quanto B permanecerão indefinidamente no loop mais interno, pois ambos farão a leitura read(busy == true).

Starvation-freedom:
------------------------------------

XXX: Não foi explicitamente dito no livro, mas pelos exemplos dados (Peterson Lock e Filter Lock), quando um algoritmo satisfaz a exclusão mútua e é starvation-free, ele é deadlock-free.

Suponhamos que Flaky Lock seja starvation-free. Provamos que o protocolo satisfaz exclusão mútua. Poderíamos então deduzir que o algoritmo é deadlock-free. No entanto isso é uma contradição, já que provamos que o Flaky Lock não é deadlock-free.

FlakyLock, portanto, não é starvation-free.

======= Exercício 15: =======

A seguinte execução mostra que o algoritmo FastPath não satisfaz a exclusão mútua:

write_a(x = A) -> read_a(y == -1) -> write_b(x = B) -> read_b(y == -1) -> write_a(y = A) -> read_a(x != A) -> lock_a -> CS_a -> read_b(x == B) -> CS_b

A declaração dos cientistas da Cantaloupe-Melon University não está correta.

======= Exercício 16: =======

Pelo código, vemos que:

Valor inicial: goRight = false

RIGHT: write_r(last = R) -> read_r(goRight == true) -> CS_r
STOP:  write_s(last = S) -> read_s(goRight == false) -> write_s(goRight = true) -> read_s(last == S) -> CS_s
DOWN:  write_d(last = D) -> read_d(goRight == false) -> write_d(goRight = true) -> read_d(last != D) -> CS_d

------------------ No máximo uma thread terá o valor STOP: ------------------
Hipótese: É possível que mais de uma thread ter o valor STOP.
Isso implica em I ou II:

I) write_a(goRight = true) -> read_b(goRight == false)
Fazendo com que B tenha valor RIGHT.

II) read_b(goRight == false) -> write_a(goRight = true)
Logo: write_b(last = B) -> read_a(last == A)
Fazendo com que A tenha valor DOWN.


Como I e II rejeitam a hipótese, então não é possível que mais de uma thread ter o valor STOP.

------------------

A execução a seguir mostra que é possível uma thread ter o valor STOP.
write_s(last = S) -> read_s(goRight == false) -> write_s(goRight = true) -> read_s(last == S)

------------------

Conclusão: No máximo uma thread terá o valor STOP.

------------------ No máximo n-1 threads terão o valor DOWN:  ------------------

Hipótese: Todas as n threads terão o valor DOWN.
Isso implica em I ou II:

I) write_ai(goRight = true) -> read_aj(goRight == false)
Fazendo com que pelo menos uma thread tenha valor RIGHT.

II) read_ai(goRight == false) -> write_ai(goRight = true) [para todo i variando de 1 a n]
Logo existe uma thread(índice l) que executou por último:
write_al(last = Al)
Isso implica que esta thread terá como valor STOP.


Como I e II rejeitam a hipótese, então não é possível que as n threads tenham o valor DOWN.

------------------

Caso todas as threads executem as instruções a seguir (para todo i variando de 1 a n):
write_ai(last = Ai) -> read_ai(goRight == false)

Seguidos da execução de (para todo i variando de 1 a n):
write_ai(goRight = true) -> read_ai(last == Ai)

Como last terá o valor do índice da última thread que executou:
write_al(last = Al)

Necessariamente Al terá o valor STOP, e as demais n-1 threads terão o valor DOWN.

------------------

Conclusão: No máximo n-1 threads terão o valor DOWN.

------------------ No máximo n-1 threads terão o valor RIGHT:  ------------------

Hipótese: Todas as n threads terão o valor RIGHT.
Isso implica em I ou II:

I) read_ai(goRight == false) -> write_ai(goRight = true) [para todo i variando de 1 a n]
Logo nenhuma thread terá o valor RIGHT.

II) write_ai(goRight = true) -> read_aj(goRight == false)
Como:
read_ai(goRight == false) -> write_ai(goRight = true)
Logo, o valor de Ai será diferente de RIGHT.


Como I e II rejeitam a hipótese, então não é possível que as n threads tenham o valor RIGHT.

------------------

Caso a primeira thread execute as instruções:
write_a1(last = A1) -> read_a1(goRight == false) -> write_a1(goRight = true)
Esta terá um valor diferente de RIGHT.

As demais threads executarão as instruções a seguir (para todo i variando de 2 a n):
write_ai(last = Ai) -> read_ai(goRight == false)
Logo terão o valor RIGHT.

------------------

Conclusão: No máximo n-1 threads terão o valor RIGHT.

