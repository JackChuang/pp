  - O protocolo satisfaz a exclusão mútua. 

    Prova: Suponha que não. Considere que as threads A e B estão executando concorrentemente a região crítica.

           Se A e B estão executando a região crítica, temos que: 
               1. write_a(turn = A) -> read_a(busy) -> write_a(busy = true) -> read_a(turn) -> CS_a
               2. write_b(turn = B) -> read_b(busy) -> write_b(busy = true) -> read_b(turn) -> CS_b

           Assuma, sem perda de generaliade, que A foi a primeira thread a entrar na região crítica. Dessa, forma temos que:
               3. read_a(turn == A) -> write_b(turn = B)

           A Eq. 3 implica que B observou a variável `busy` na Eq. 2 como `true`.
           Como B não pode ter entrado na região crítica enquanto `busy` é `true`, CS_a -> CS_b. Uma contradição.
           
         
  - O protocolo não é starvation-free.
  
    Considere o seguinte cenário:
        1. Thread A chama o método lock(), entra no loop interno e escreve `turn = A`
        2. Thread B chama o método lock(), entra no loop interno e escreve `turn = B`
        3. Thread B sai do loop interno, encreve `busy = true`, sai do loop externo e entra na região crítica
        4. Thread A continua executando o loop interno
        5. Thread B sai da região crítica e escreve `busy = false`
        6. Thread B chama o método lock() novamente, entra no loop interno e escreve `turn = B`
        
     O cenário acima pode continuar indefinidamente sem que a Thread A entre na região crítica.
    
    
  - O protocolo não é deadlock-free.
  
    Considere o seguinte cenário:
        1. Thread A chama o método lock(), entra no loop interno e escreve `turn = A`
        2. Thread B chama o método lock(), entra no loop interno e escreve `turn = B`
        3. Thread B sai do loop interno e encreve `busy = true`
        4. Thread A continua executando o loop interno e escreve `turn = A`
        5. Thread B executa o loop externo e entra novamente no loop interno pois `turn == A`
        
    No cenário acima as duas threads ficarão executando o loop interno indefinidamente já que `busy == true`.