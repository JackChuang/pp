C02E11

A)
Prova por contradição. Supondo que o algoritmo não satisfaz exclusão mútua.
Analisando o código nos temos que:

	writeA(turn = A) -> readA(busy == false) -> writeA(busy = true) -> readA(turn == A) -> CSA
	writeB(turn = B) -> readB(busy == false) -> writeB(busy = true) -> readB(turn == B) -> CSB
	readA(busy == false) -> writeB(busy = true)

	writeA(turn = A) -> readA(busy == false) -> writeB(busy = true) -> readB(turn == B) 

como "writeA(turn = A) -> readB(turn == B)" é uma contradição, nos temos que a suposição inicial é falsa.

B) Um exemplo de execução que leva a starvation de uma thread: 

writeA(turn = A) -> readA(busy == false) -> writeA(busy == true) -> writeB(turn = B) -> readA(turn != A)
deste ponto em diante, nos temos busy = true, que não poderá mais ser modificado.

C)
Deadlock só poderia ocorrer caso seja invocado o método "lock()" e mas nunca conseguir de fato acesso ao lock. 

Como no caso acima:
writeA(turn = A) -> readA(busy == false) -> writeA(busy == true) -> writeB(turn = B) -> readA(turn != A)
deste ponto em diante, nos temos busy = true, que não poderá mais ser modificado. 
